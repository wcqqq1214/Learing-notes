( [三次握手、四次挥手 | 爱编程的大丙](https://subingwen.cn/linux/three-four/) )

TCP 协议是一个安全的、面向连接的、流式传输协议，所谓的面向连接就是三次握手，对于程序员来说只需要在客户端调用 `connect()` 函数，三次握手就自动进行了。先通过下图看一下 TCP 协议的格式，然后再介绍三次握手的具体流程 : 

### 1. TCP 协议介绍

![[TCP协议.png]]

TCP 协议中，比较重要的字段有 : 

- 源端口 : 表示发送端端口号，字段长 16 位，2 个字节
- 目的端口 : 表示接收端端口号，字段长 16 位，2 个字节
- 序号 ( sequence number ) : 字段长 32 位，占 4 个字节，序号的范围为 \[0，4284967296]
	- 由于 TCP 是面向字节流的，在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号
	- 首部中的序号字段则是指本报文段所发送的数据的第一个字节的序号，这是随机生成的
	- 序号是循环使用的，当序号增加到最大值时，下一个序号就又回到了 0
- 确认序号 ( acknowledgement number ) : 占 32 位 ( 4字节 ) ，表示收到的下一个报文段的第一个数据字节的序号，如果确认序号为 N，序号为 S，则表明到序号 N-S 为止的所有数据字节都已经被正确地接收到了
- 8个标志位 ( Flag ) :
	- CWR : CWR 标志与后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 标志为 1 时，则通知对方已将拥塞窗口缩小
	- ECE : 若其值为 1 则会通知对方，从对方到这边的网络有阻塞。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1
	- URG : 该位设为 1，表示包中有需要紧急处理的数据，对于需要紧急处理的数据，与后面的紧急指针有关
	- **ACK : 该位设为 1，确认应答的字段有效，TCP规定除了最初建立连接时的 SYN 包之外该位必须设为 1**
	- PSH : 该位设为 1，表示需要将收到的数据立刻传给上层应用协议，若设为 0，则先将数据进行缓存
	- RST : 该位设为 1，表示 TCP 连接出现异常必须强制断开连接
	- **SYN : 用于建立连接，该位设为 1，表示希望建立连接，并在其序列号的字段进行序列号初值设定**
	- **FIN : 该位设为 1，表示今后不再有数据发送，希望断开连接**
- 窗口大小：该字段长 16 位，表示从确认序号所指位置开始能够接收的数据大小，TCP 不允许发送超过该窗口大小的数据


---
---
### 2. 三次握手

TCP 连接是双向连接，客户端和服务器需要分别向对方发送连接请求，并且建立连接，三次握手成功之后，二者之间的双向连接也就成功建立了。如果要保证三次握手顺利完成，必须要满足以下条件 : 

服务器端 : 已经启动，并且启动了监听 ( 被动接受连接的一端 ) 
客户端 : 基于服务器端监听的 IP 和端口，向服务器端发起连接请求 ( 主动发起连接的一端 ) 

![[三次握手.png]]

三次握手具体过程如下 : 

第一次握手 : 
- 客户端 : 客户端向服务器端发起连接请求将报文中的 SYN 字段置为 1，生成随机序号 x，seq = x
- 服务器端 : 接收客户端发送的请求数据，解析 TCP 协议，校验 SYN 标志位是否为 1，并得到序号 x

第二次握手 : 
- 服务器端 : 给客户端回复数据
	1. 回复 ACK，将 TCP 协议 ACK 对应的标志位设置为 1，表示同意了客户端建立连接的请求
	2. 回复了 ack = x + 1，这是确认序号
		- x : 客户端生成的随机序号
		- 1 : 客户端给服务器发送的数据的量，SYN 标志位存储到某一个字节中，因此按照一个字节计算，表示客户端给服务器发送的 1 个字节服务器收到了
	3. 将 TCP 协议中的 SYN 对应的标志位设置为 1，服务器向客户端发起了连接请求
	4. 服务器端生成了一个随机序号 y，发送给了客户端

- 客户端 : 接收回复的数据，并解析 TCP 协议
	1. 校验ACK标志位，为 1 表示服务器接收了客户端的连接请求
	2. 数据校验，确认发送给服务器的数据服务器收到了没有，计算公式如下 : 
		发送的数据的量 = 使用服务器回复的确认序号 - 客户端生成的随机序号 ===> 1 = x + 1 - x
	3. 校验 SYN 标志位，为 1 表示服务器请求和客户端建立连接
	4. 得到服务器生成的随机序号 : y

第三次握手 : 
- 客户端 : 发送数据给服务器
	1. 将 TCP 协议中 ACK 标志位设置为 1，表示同意了服务器的连接请求
	2. 给服务器回复了一个确认序号 ack = y + 1
		- y : 服务器端生成的随机序号
		- 1 : 服务器给客户端发送的数据量，服务器给客户端发送了 ACK 和 SYN，都存储在这一个字节中
	3. 发送给服务器的序号就是上一次从服务器端收的确认序号因此 seq = x + 1

- 服务器端 : 接收数据，并解析 TCP 协议
	1. 查看 ACK 对应的标志位是否为 1，如果是 1 代表，客户端同意了服务器的连接请求
	2. 数据校验，确认发送给客户端的数据客户端收到了没有，计算公式如下 : 
		给客户端发送的数据量 = 确认序号 - 服务器生成的随机序号 ===> 1 = y + 1 - y
	3. 得到客户端发送的序号 : x + 1


---
---
### 3. TCP 四次挥手

四次挥手是断开连接的过程，需要双向断开，关于由哪一端先断开连接是没有要求的。通信的两端如果想要断开连接就需要调用 `close()` 函数，当两端都调用了该函数，四次挥手也就完成了

- 客户端和服务器断开连接 -> 单向断开
- 服务器和客户端断开连接 -> 单向断开

进行了两次单向断开，双向断开就完成了，每进行一次单向断开，就会完成两次挥手的动作

![[TCP四次挥手.png]]

基于上图的例子对四次挥手的具体过程进行阐述 ( **实际上哪端先断开连接都是允许的** ) : 

第一次挥手 :
- 主动断开连接的一方 : 发送断开连接的请求
	1. 将 TCP 协议中 FIN 标志位设置为 1，表示请求断开连接
	2. 发送序号 x 给对端，seq = x，基于这个序号用于客户端数据校验的计算
- 被动断开连接的一方 : 接收请求数据，并解析 TCP 协议
	1. 校验 FIN 标志位是否为 1
	2. 收到了序号 x，基于这个数据计算回复的确认序号 ack 的值

第二次挥手 :
- 被动断开连接的一方 : 回复数据
	1. 同意了对方断开连接的请求，将 ACK 标志位设置为 1
	2. 回复 ack = x + 1，表示成功接受了客户端发送的一个字节数据
	3. 向客户端发送序号 seq = y，基于这个序号用于服务器端数据校验的计算
- 主动断开连接的一方 : 接收回复数据, 并解析 TCP 协议
	1. 校验 ACK 标志位，如果为 1 表示断开连接的请求对方已经同意了
	2. 校验 ack 确认发送的数据服务器是否收到了，发送的数据 = ack - x = x + 1 - x = 1

第三次挥手 :
- 被动断开连接的一方 : 将 TCP 协议中 FIN 标志位设置为 1，表示请求断开连接
- 主动断开连接的一方 : 接收请求数据, 并解析 TCP 协议，校验 FIN 标志位是否为 1 

第四次挥手 :
- 主动断开连接的一方 : 回复数据
	1. 将 TCP 协议中 ACK 对应的标志位设置为 1，表示同意了断开连接的请求
	2. ack = y + 1，表示服务器发送给客户端的一个字节客户端接收到了
	3. 序号 seq = h，此时的 h 应该等于 x + 1，也就是第三次挥手时服务器回复的确认序号 ack 的值
- 被动断开连接的一方 : 收到回复的 ACK，此时双向连接双向断开，通信的两端没有任何关系了


---
---
### 4. 流量控制

流量控制可以让发送端根据接收端的实际接受能力控制发送的数据量。它的具体操作是，**接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不会超过该大小的数据，该限制大小即为窗口大小，即窗口大小由接收端主机决定**

TCP 首部中，专门有一个字段来通知窗口大小，接收主机将自己可以接收的缓冲区大小放在该字段中通知发送端。**当接收端的缓冲区面临数据溢出时，窗口大小的值也是随之改变，设置为一个更小的值通知发送端，从而控制数据的发送量，这样达到流量的控制**。这个控制流程的窗口也可以称作滑动窗口

这个图是一个单向的数据发送 :
![[流量控制.png]]

左侧是数据发送端 : 对应的是发送端的写缓冲区 ( 内存 ) ，通过一个环形队列进行数据管理
- 白色格子 : 空闲的内存，可以写数据
- 粉色的格子 : 被写入到内存，但是还没有被发送出去的数据
- 灰色的格子 : 代表已经被发送出去的数据

右侧是数据接收端 : 对应的是接收端的读缓冲区，存储发送端发送过来的数据
- 白色格子 : 空闲的内存，可以继续接收数据，滑动窗口的值记录的就是白色的格子的大小
	- 随着接收的数据越来越多，白色格子越来越少，滑动窗口的值越来越小
	- 如果白色格子没有了，滑动窗口变为 0，这时候, 发送端就被阻塞了
- 粉色格子 : 接收的数据，但是这个数据还没有从内核中读走，使用 `read() / recv()`
	粉色格子变少了，可用空间就变多了，滑动窗口的值就变大了
	如果滑动窗口的值从 0 变为大于 0，接收端又重新有容量接收数据了，发送端的阻塞自动解除，继续发送数据

基于 TCP 通信的流程图，记录了从三次握手 -> 数据通信 -> 四次挥手是全过程 : 

![[TCP通信全过程图.png]]

```Shell
# fast sender: 客户端
# slow recerver: 服务器
# win: 滑动窗口大小
# mss: maximum segment size, 单条数据的最大长度
```

第 1 步 : 第一次握手，发送连接请求 SYN 到服务器端

- 0(0)：0表示客户端生成的随机序号，(0)表示客户端没有额外给服务器发送数据, 因此数据的量为0
- win4096: 客户端告诉服务器, 能接收的数据(缓存)的最大量为4k
- mss1460: 客户端可以处理的单条最大字节数是1460字节

第 2 步 : 第二次握手

- ACK : 服务器同意了客户端的连接请求
	- SYN : 服务器请求和客户端建立连接
- 8000(0) : 8000是服务器端生成的随机序号，(0) 表示服务器没有额外给客户端发送数据，因此数据的量为 0
- 1 : 发送给客户端的确认序号
	- 确认序号 = 客户端生成的随机序号 + 客户端给服务器发送的数据量 ( 字节数 ) ===> 1 = 0 + 1
	- 表示客户端给服务器发送的 1 个字节服务器收到了
- win6144 : 服务器告诉客户端我能最多缓存 6k 数据
- mss1024 : 服务器能处理的单条数据最大长度是 1k

第 3 步 : 第三次握手

- ACK : 客户端同意了服务器的连接请求
- 8001 : 发送给服务器的确认序号
	- 确认序号 = 服务器生成的随机序号 + 服务器给客户端发送的数据量 ===> 8001 = 8000 + 1
	- 客户端告诉服务器，你给我发送的 1 个字节的数据我收到了
- win4096 : 告诉服务器客户端能缓存的最大数据量是 4k

第 4 ~ 9 步 : 客户端给服务器发送数据

- 1(1024) :  1 ( 1-0 ) 表示之前一共给服务器发送了 1 个字节，(1024) 表示这次要发送的数据量为 1k
- 1025(1024) :  1025 ( 1025-0 ) 表示之前一共给服务器发送了 1025 个字节，(1024) 表示这次要发送的数据量为 1k
- 2049(1024) :  2049 ( 2049-0 ) 表示之前一共给服务器发送了 2049 个字节，(1024) 表示这次要发送的数据量为 1k
- 第 9 步完成之后，服务器的滑动窗口变为 0，接收数据的缓存被写满了，发送端阻塞

第 10 步 : 

- ack6145 : 服务器给客户端回复数据，6145 是确认序号，代表实际接收的字节数
	服务器实际接收的字节数 = 确认序号 - 客户端生成的随机序号 ===> 6145 = 6145 - 0
- win2048 : 服务器告诉客户端我的缓存还有 2k，也就是还有 4k 还在缓存中没有被读走

第 11 步 : win4096 表示滑动窗口变为 4k，代表还可以接收 4k 数据，还有 2k 在缓存中

第 12 步 : 客户端又给服务器发送了 1k 数据

第 13 步 : 第一次挥手，FIN 表示客户端主动和服务器断开连接，并且发送了 1k 数据到服务器端

第 14 步 : 第二次挥手，回复 ACK，同意断开连接

第 15, 16 步 : 服务器端从读缓冲区中读数据，第 16 步数据读完，滑动窗口变成最大的 6k

第 17 步 :

- FIN : 服务器请求和客户端断开连接
- 8001(0) : 服务器一共给客户端发送的字节数 :  8001 - 8000 = 1 个字节，携带的数据量为 0 ( FIN 不计算在内 ) 
- ack8194 : 服务器收到了客户端的多少个字节 : 8194 - 0 = 8194 个字节

第 18 步 : 第四次挥手
- ACK : 客户端同意了服务器断开连接的请求
- 8002 : 确认序号，可以计算出服务器给客户端发送了多少数据，8002 - 8000 = 2 个字节
