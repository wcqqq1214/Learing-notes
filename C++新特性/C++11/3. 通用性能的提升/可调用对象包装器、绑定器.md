### 1. 可调用对象

在 C++ 中存在 "可调用对象" 这么一个概念。准确来说，可调用对象有如下几种定义 :

1. 是一个函数指针 ( 语法 : `返回类型 (*指针名)(参数列表) = &函数名;` )
```cpp
int print(int a, double b) {
    cout << a << b << endl;
    return 0;
}

// 定义函数指针
int (*func)(int, double) = &print;  // & 可省略
```

2. 是一个具有 `operator()` 成员函数的类对象 ( 仿函数 ) 
```cpp
#include <iostream>
#include <string>
using namespace std;

struct Test {
    // ()操作符重载
    void operator()(string msg) {
        cout << "msg: " << msg << endl;
    }
};

int main() {
    Test t;
    t("我是要成为海贼王的男人!!!");	// 仿函数
    
    return 0;
}
```

3. 是一个可被转换为函数指针的类对象
```cpp
#include <iostream>
#include <string>
using namespace std;

using func_ptr = void(*)(int, string);
struct Test {
    static void print(int a, string b) {
        cout << "name: " << b << ", age: " << a << endl;
    }

    // 将类对象转换为函数指针
    operator func_ptr() {
        return print;
    }
};

int main() {
    Test t;
    // 对象转换为函数指针, 并调用
    t(19, "Monkey D. Luffy");

    return 0;
}
```

4. 是一个类成员函数指针或者类成员指针
```cpp
#include <iostream>
#include <string>
using namespace std;

struct Test {
    void print(int a, string b) {
        cout << "name: " << b << ", age: " << a << endl;
    }
    
    int m_num;
};

int main() {

    // 定义类成员函数指针指向类成员函数 (Test::* 表示指针是指向 Test 类的成员函数, 而不是普通的全局或静态函数)
    void (Test::*func_ptr)(int, string) = &Test::print;
    
    // 类成员指针指向类成员变量 (Test::* 表示这是一个指向 Test 类成员变量的指针)
    int Test::*obj_ptr = &Test::m_num;

    Test t;
    
    // 通过类成员函数指针调用类成员函数
    (t.*func_ptr)(19, "Monkey D. Luffy");
    
    // 通过类成员指针初始化类成员变量
    t.*obj_ptr = 1;
    
    cout << "number is: " << t.m_num << endl;

    return 0;
}
```

在上面的例子中满足条件的这些可调用对象对应的类型被统称为可调用类型。C++ 中的可调用类型虽然具有比较统一的操作形式，但定义方式五花八门，这样在我们试图使用统一的方式保存，或者传递一个可调用对象时会十分繁琐。现在，C++11 通过提供 `std::function` 和 `std::bind` 统一了可调用对象的各种操作


---
### 2. 可调用对象包装器

`std::function` 是可调用对象的包装器。它是一个类模板，可以容纳除了类 ( 非静态 ) 成员 ( 函数 ) 指针之外的所有可调用对象。通过指定它的模板参数，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们

#### 2.1 基本用法

`std::function` 必须要包含一个叫做 `functional` 的头文件，可调用对象包装器使用语法如下 :
```cpp
#include <functional>
std::function<返回值类型(参数类型列表)> diy_name = 可调用对象;
```

- 下面的实例代码中演示了可调用对象包装器的基本使用方法 : 
```cpp
#include <iostream>
#include <functional>
using namespace std;

int add(int a, int b) {
    cout << a << " + " << b << " = " << a + b << endl;
    return a + b;
}

class T1 {
public:
    static int sub(int a, int b) {
        cout << a << " - " << b << " = " << a - b << endl;
        return a - b;
    }
};

class T2 {
public:
    int operator()(int a, int b) {
        cout << a << " * " << b << " = " << a * b << endl;
        return a * b;
    }
};

int main() {
    // 绑定一个普通函数
    function<int(int, int)> f1 = add;
    
    // 绑定一个静态类成员函数
    function<int(int, int)> f2 = T1::sub;
    
    // 绑定一个仿函数
    T2 t;
    function<int(int, int)> f3 = t;

    // 函数调用
    f1(9, 3);
    f2(9, 3);
    f3(9, 3);

    return 0;
}
```

- 输入结果如下 :
```
9 + 3 = 12
9 - 3 = 6
9 * 3 = 27
```

通过测试代码可以得到结论 :    `std::function` 可以将可调用对象进行包装，得到一个统一的格式，包装完成得到的对象相当于一个函数指针，和函数指针的使用方式相同，通过包装器对象就可以完成对包装的函数的调用了

#### 2.2 作为回调函数使用

因为回调函数本身就是通过函数指针实现的，使用对象包装器可以取代函数指针的作用，来看一下下面的例子 : 
```cpp
#include <iostream>
#include <functional>
using namespace std;

class A {
public:
    // 构造函数参数是一个包装器对象
    A(const function<void()>& f) : callback(f) {}

    void notify() {
        callback(); // 调用通过构造函数得到的函数指针
    }
    
private:
    function<void()> callback;
};

class B {
public:
    void operator()() {
        cout << "我是要成为海贼王的男人!!!" << endl;
    }
};

int main() {
    B b;
    A a(b); // 仿函数通过包装器对象进行包装
    a.notify();

    return 0;
}
```

通过上面的例子可以看出，使用对象包装器 `std::function` 可以非常方便的将仿函数转换为一个函数指针，通过进行函数指针的传递，在其他函数的合适的位置就可以调用这个包装好的仿函数了

另外，使用 `std::function` 作为函数的传入参数，可以将定义方式不相同的可调用对象进行统一的传递，这样大大增加了程序的灵活性


---
### 3. 绑定器

`std::bind` 用来将可调用对象与其参数一起进行绑定。绑定后的结果可以使用 `std::function` 进行保存，并延迟调用到任何我们需要的时候。通俗来讲，它主要有两大作用 :
1. 将可调用对象与其参数一起绑定成一个仿函数
2. 将多元 ( 参数个数为 n，n > 1 ) 可调用对象转换为一元或者 ( n -  1 ) 元可调用对象，即只绑定部分参数

- 绑定器函数使用语法格式如下 : 
```cpp
// 绑定非类成员函数/变量
auto f = std::bind(可调用对象地址, 绑定的参数/占位符);

// 绑定类成员函/变量
auto f = std::bind(类函数/成员地址, 类实例对象地址, 绑定的参数/占位符);
```

- 下面来看一个关于绑定器的实际使用的例子 : 
```cpp
#include <iostream>
#include <functional>
using namespace std;

void callFunc(int x, const function<void(int)>& f) {
    if (x % 2 == 0) {
        f(x);
    }
}

void output(int x) {
    cout << x << " ";
}

void output_add(int x) {
    cout << x + 10 << " ";
}

int main() {
    // 使用绑定器绑定可调用对象和参数
    auto f1 = bind(output, placeholders::_1);
    for (int i = 0; i < 10; ++i) {
        callFunc(i, f1);
    }
    cout << endl;

    auto f2 = bind(output_add, placeholders::_1);
    for (int i = 0; i < 10; ++i) {
        callFunc(i, f2);
    }
    cout << endl;

    return 0;
}
```

- 测试代码输出的结果 : 
```
0 2 4 6 8
10 12 14 16 18
```

在上面的程序中，使用了 `std::bind` 绑定器，在函数外部通过绑定不同的函数，控制了最后执行的结果。`std::bind` 绑定器返回的是一个仿函数类型，得到的返回值可以直接赋值给一个 `std::function` ，在使用的时候我们并不需要关心绑定器的返回值类型，使用 `auto` 进行自动类型推导就可以了

`placeholders::_1` 是一个占位符，代表这个位置将在函数调用时被传入的第一个参数所替代。同样还有其他的占位符 `placeholders::_2` ，`placeholders::_3` ，`placeholders::_4` ，`placeholders::_5` 等

- 有了占位符的概念之后，使得 `std::bind` 的使用变得非常灵活 :
```cpp
#include <iostream>
#include <functional>
using namespace std;

void output(int x, int y) {
    cout << x << " " << y << endl;
}

int main() {
    // 使用绑定器绑定可调用对象和参数, 并调用得到的仿函数
    bind(output, 1, 2)();
    bind(output, placeholders::_1, 2)(10);
    bind(output, 2, placeholders::_1)(10);

    // error, 调用时没有第二个参数
    // bind(output, 2, placeholders::_2)(10);
    // 调用时第一个参数 10 被吞掉了, 没有被使用
    bind(output, 2, placeholders::_2)(10, 20);

    bind(output, placeholders::_1, placeholders::_2)(10, 20);
    bind(output, placeholders::_2, placeholders::_1)(10, 20);

    return 0;
}
```

- 示例代码执行的结果 : 
```
1  2		// bind(output, 1, 2)();
10 2		// bind(output, placeholders::_1, 2)(10);
2 10		// bind(output, 2, placeholders::_1)(10);
2 20		// bind(output, 2, placeholders::_2)(10, 20);
10 20		// bind(output, placeholders::_1, placeholders::_2)(10, 20);
20 10		// bind(output, placeholders::_2, placeholders::_1)(10, 20);
```

通过测试可以看到，`std::bind` 可以直接绑定函数的所有参数，也可以仅绑定部分参数。在绑定部分参数的时候，通过使用 `std::placeholders` 来决定空位参数将会属于调用发生时的第几个参数

可调用对象包装器 `std::function` 是不能实现对 类成员函数指针 或者 类成员指针 的包装的，但是通过绑定器 `std::bind` 的配合之后，就可以完美的解决这个问题了，再来看一个例子，然后再解释里边的细节 :
```cpp
#include <iostream>
#include <functional>
using namespace std;

class Test {
public:
    void output(int x, int y) {
        cout << "x: " << x << ", y: " << y << endl;
    }
    
    int m_number = 100;
};

int main() {
    Test t;
    
    // 绑定类成员函数
    function<void(int, int)> f1 = bind(&Test::output, &t, placeholders::_1, placeholders::_2);
    
    // 绑定类成员变量 (公共)
    function<int&(void)> f2 = bind(&Test::m_number, &t);

    // 调用
    f1(520, 1314);
    f2() = 2333;
    cout << "t.m_number: " << t.m_number << endl;

    return 0;
}
```

- 示例代码输出的结果 :
```
x: 520, y: 1314
t.m_number: 2333
```

在用绑定器绑定类成员函数或者成员变量的时候需要将它们所属的实例对象一并传递到绑定器函数内部。`f1` 的类型是 `function<void(int, int)>` ，通过使用 `std::bind` 将 `Test` 的成员函数 `output` 的地址和对象 `t` 绑定，并转化为一个仿函数并存储到对象 `f1` 中

使用绑定器绑定的类成员变量 `m_number` 得到的仿函数被存储到了类型为 `function<int&(void)>` 的包装器对象 `f2` 中，并且可以在需要的时候修改这个成员。其中 `int` 是绑定的类成员的类型，并且允许修改绑定的变量，因此需要指定为变量的引用，由于没有参数因此参数列表指定为 `void` 

示例程序中是使用 `function` 包装器保存了 `bind` 返回的仿函数，如果不知道包装器的模板类型如何指定，可以直接使用 `auto` 进行类型的自动推导，这样使用起来会更容易一些
