### 1. C++98 标准的类成员初始化

在 C++98 中，支持了在类声明中使用等号 `=` 加初始值 的方式，来初始化类中静态成员常量 。这种声明方式我们也称之为 "就地" 声明。而非静态成员变量的初始化则必须在构造函数中进行

```cpp
1. struct Base {
2. 
3.     Base() : a(250) {}
4.     Base(int num) : a(num) {}
5.
6.     int a;
7.     int b = 1;	
8.     static int c = 0;	
9.     static const double d = 3.14;	
10.    static const char* const e = "i am luffy";	
11.    const static int f = 0;	
12. };
```

如果按照 C++98 标准来解读上面这段代码 ，其中有这么几行语法是错误的 :
1. 第 `7` 行 :    类的非静态成员，必须在构造函数中进行初始化
2. 第 `8` 行 :    类的静态成员，必须在类的外部进行初始化 
	( C++17 也会报错 )
3. 第 `9` 行 :    类的静态常量成员，但不是整形或者枚举，无法通过编译
	( 如果使用 g++ 可能发现就地初始化 `double` 类型的静态常量是可以通过编译的，不过这实际是 GNU 对C++的一个扩展，并不遵从 C++ 标准 )
4. 第 `10` 行 :    类的静态常量成员，但不是整形或者枚举，无法通过编译 
	( C++17 也会报错 )
5. 第 `8` 、 `10` 行的变量初始化要在类的外部 :
```cpp
int Base::c = 110;
const char* const Base::e = "i am luffy";
```
ps :    上面程序中的 `static const` 和 `const static` 是等价的


---
### 2. C++11 标准的类成员初始化

#### 2.1 初始化类的非静态成员

在进行类成员变量初始化的时候，C++11 标准对于 C++98 做了补充，允许在定义类的时候在类内部直接对非静态成员变量进行初始化，在初始化的时候可以使用等号 `=` 也可以使用花括号 `{}`
```cpp
class Test {
private:
    int a = 9;
    int b = {5};
    int c{12};
    double array[4] = {3.14, 3.15, 3.16, 3.17};
    double array1[4] {3.14, 3.15, 3.16, 3.17};
    string s1("hello");     // error
    string s2{"hello, world"};
};
```

可以看到如果使用花括号 `{}` 的方式对类的非静态成员进行初始化，等号是可以省略不写的
( 不能使用 小括号 `()` 初始化对象，应该使用 花括号 `{}` )

#### 2.2 类内部赋值和初始化列表

在 C++11 之前对于非静态的类成员变量我们除了在构造函数内部进行赋值，也可以在类的初始化列表中进行初始化 ( 这种方式比在构造函数内部赋值效率高 ) 。那么，如果同时 在类内部对非静态成员变量就地初始化 和 在初始化列表中进行初始化 会怎么样呢？下面来测试一下 :
```cpp
1.  class Init {
2.  public:
3.      Init(int x, int y, int z) : a(x), b(y), c(z) {}
4.
5.      int a = 1;
6.      int b = 2;
7.      int c = 3;
8.  };
9.
10. int main() {
11.     Init tmp(10, 20, 30);
12.     cout << "a: " << tmp.a << ", b: " << tmp.b << ", c: " << tmp.c << endl;
13.     return 0;
14. }
```

第 `3` 行 :    使用初始化列表对类的非静态成员进行初始化
第 `5` 、`6` 、`7` 行 :    在类内部对非静态成员变量就地初始化 ( C++11 新特性 )
执行程序，输出的结果如下 :
```
1
a: 10, b: 20, c: 30
```
1. 我们可以从函数的打印输出中看到，在类内部就地初始化和初始化列表并不冲突 ( 程序可以正常运行 ) 
2. 程序员可以为同一成员变量既在类内部就地初始化，又在初始化列表中进行初始化，只不过初始化列表总是看起来 **后作用于** 非静态成员
3. 也就是说，**通过初始化列表指定的值会覆盖就地初始化时指定的值**

