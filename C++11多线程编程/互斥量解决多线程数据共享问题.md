
1. 在多个线程中共享数据时，需要注意 **线程安全** 问题
2. 如果多个线程同时访问同一个变量，并且其中至少有一个线程对该变量进行了写操作，那么就会出现数据竞争问题
3. 数据竞争可能会导致程序崩溃、产生未定义的结果，或者得到错误的结果


- **解决方法 :**
1. 为了避免数据竞争问题，需要使用 **同步机制** 来确保多个线程之间对共享数据的访问是安全的
2. 常见的同步机制包括 互斥量、条件变量、原子操作 等
	( C++11的互斥量 : `std::mutex` )

*ps :    线程安全 :  如果多线程程序每一次的运行结果和单线程运行的结果始终是一样的，那么线程就是安全的*


---

##### 互斥量

- **概念**
	1. 互斥量 ( `mutex` ) 是一种用于实现多线程同步的机制，用于确保多个线程之间对共享资源的访问互斥
	2. 互斥量通常用于保护共享数据的访问，以避免多个线程同时访问同一个变量或者数据结构而导致的数据竞争问题

- **基本操作 :**
	1. 互斥量提供了两个基本操作 : `lock()` 和 `unlock()`
	2. 当一个线程调用 `lock()` 函数时，如果互斥量当前没有被其他线程占用，则该线程获得该互斥量的所有权，可以对共享资源进行访问
	3. 如果互斥量当前已经被其他线程占用，则调用 `lock()` 函数的线程会被阻塞，直到该互斥量被释放为止

- 例 :
```cpp
#include <iostream>
#include <thread>
#include <mutex>

int shared_data = 0;
std::mutex mtx;

void func() {
    for (int i = 0; i < 100000; i++) {
        mtx.lock();
        shared_data++;
        mtx.unlock();
    }
}

int main() {

    std::thread t1(func);
    std::thread t2(func);

    t1.join();
    t2.join();
    std::cout << shared_data << std::endl;

    return 0;
}
```

1. 在 `func` 函数中，先调用 `mtx.lock()` 来获取互斥量的所有权
2. 然后对 `shared_data` 变量进行累加操作
3. 最后再调用 `mtx.unlock()` 来释放互斥量的所有权
( 这样就可以确保多个线程之间对 `shared_data` 变量的访问是安全的 )


